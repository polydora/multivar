---
title: "Краткое введение в мир матричной алгебры"
subtitle: "Анализ и визуализация многомерных данных с использованием R"
author: Вадим Хайтов, Марина Варфоломеева
presenters: [{
    name: 'Вадим Хайтов',
    company: 'Каф. Зоологии беспозвоночных, СПбГУ',
    }]
output:
  ioslides_presentation:
    widescreen: true
    css: my_styles.css
    logo: course_logo.png
---

## Вы сможете
- Объяснить что такое матрицы и какие бывают их основные разновидности
- Выполнить базовые операции с матрицами с использованием функций R
- Применить в среде R методы матричной алгебры для решения простейших задач




```{r setup, include=FALSE, cache=FALSE}
#-- RUN THE FRAGMENT BETWEEN LINES BEFORE COMPILING MARKDOWN
# to configure markdown parsing
options(markdown.extensions = c("no_intra_emphasis", "tables", "fenced_code", "autolink", "strikethrough", "lax_spacing", "space_headers", "latex_math"))
#------
# output options
options(width = 70, scipen = 6, digits = 3)

# to render cyrillics in plots use cairo pdf
options(device = function(file, width = 7, height = 7, ...) {
 cairo_pdf(tempfile(), width = width, height = height, ...)
 })
library(knitr)
# chunk default options
opts_chunk$set(fig.align='center', tidy = FALSE, fig.width = 5, fig.height = 5, warning=FALSE, warning=FALSE, message=FALSE, cache = FALSE)
```

# Зачем нужны матрицы?

##Матричные объекты
- Есть много типов объектов, для которых такое выражение оказывается наиболее етсественным (изображения, описания многомерных объектов и т.д.)
- В матрицах, как и в обычных числах, скрыта информация, которую можно извлекать и преобразовывать по определнным правилам


## Структура матриц

$$\begin{pmatrix}
a_{11} & a_{12} & \cdots & a_{1c} \\
a_{21} & a_{22} & \cdots & a_{2c} \\    
\vdots & \vdots & \ddots & \vdots \\
a_{r1} & a_{r2} & \cdots & a_{rc}
\end{pmatrix}
    $$

Размер (порядок) матрицы $r \times c$ 

## Разновидности матриц 

Вектор-строка (row matrix)
$$ \textbf {A} =
\begin{pmatrix}
1 & 2 & 3 
\end{pmatrix}
$$

Вектор-столбец (column matrix)

$$ \textbf {B} =
\begin{pmatrix}
1 \\
4 \\    
7 \\
10 
\end{pmatrix}
$$

## Разновидности матриц 

Прямоугольные матрицы (rectangular matrices)

$$ \textbf {C} =
\begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\    
7 & 8 & 9 \\
10 & 11 & 12 
\end{pmatrix}
$$


$$ \textbf {D} =
\begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 6     
\end{pmatrix}
$$

В таком виде обычно представляются исходные данные

##Квадратные матрицы (square matrices) {.smaller}

Это наиболее "операбельные" матрицы

$$ \textbf {E} =
\begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\    
7 & 8 & 9 
\end{pmatrix}
$$

Диагональные матрицы (diagonal matrix)

$$ \textbf {F} =
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 5 & 0 & 0 \\    
0 & 0 & 9 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

##Квадратные матрицы (square matrices) {.smaller}

Треугольные матрицы (triangular matrices)
$$ \textbf {H} =
\begin{pmatrix}
1 & 2 & 3 & 4 \\
0 & 5 & 6 & 7 \\    
0 & 0 & 9 & 10 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

или

$$ \textbf {H} =
\begin{pmatrix}
1 & 0 & 0 & 0 \\
3 & 5 & 0 & 0 \\    
4 & 7 & 9 & 0 \\
5 & 8 & 10 & 11
\end{pmatrix}
$$

##Квадратные матрицы (square matrices) {.smaller}

Единичная матрица (identity matrix)
$$ \textbf {I} =
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\    
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

Единичная матрица (обозначение $\textbf{I}$) занимают особое место в матричной алгебре.   
Она выполняет ту же роль, которую выполняет единица в обычной алгебре. 


## Матрицы ассоциации

Изначально результаты исследования имеют вид исходной матрицы (обычно прямоугольной)

$$ \textbf{Y} = [n_{objects} \times p_{descriptors}]$$

Информация из этой матрицы конденсируется в двух других матрицах 


Q анализ

$$ \textbf{A}_{nn} = [n_{objects} \times n_{objects}]$$

R анализ
$$ \textbf{A}_{pp} = [p_{descriptors} \times p_{descriptors}]$$

##Матрицы ассоциации 

Это симметричные квадратные матрицы  

$$ \textbf{A}_{pp} =  
\begin{pmatrix}
a_{11} & a_{12} & \cdots & a_{1p} \\
a_{21} & a_{22} & \cdots & a_{2p} \\    
\vdots & \vdots & \ddots & \vdots \\
a_{p1} & a_{p2} & \cdots & a_{pp}
\end{pmatrix}
$$

В этой матрице $a_{ij} = a_{ji}$

Большинство многомерных методов имеет дело именно с такими матрицами

##Особенность квадратных матриц

Для квадратных матриц могут быть найдены (но не обязательно существуют) некоторые важные для матричной алгебры показатели: *определитель*, *инверсия*, *собственные значения* и *собственные вектора*




##Задание
Создайте с помощью R следующие матрицы
```{r, echo=FALSE}
matrix(1:12, ncol = 3)
```


```{r, echo=FALSE}
diag(rep(1,5))
```



#Операции с матрицами

##Транспонирование матриц

```{r}
A <- matrix(1:12, ncol = 3)
A
```

Транспонированная матрица $\textbf{A}$
```{r}
B <- t(A)
B
```

##Сложение матриц
```{r}
A + 4
```

```{r}
A + A
```

Но! Нельзя складывать матрицы разных размеров
```{r, eval=FALSE}
A + B
```

##Биологическое приложение
Предположим, что мы подсчитывали двумя разными методами крупных и мелких животных  трех  видов в одних и тех же пробах

```{r, echo = FALSE}
Large <- data.frame(Sp1 = round(rnorm(5, 10, 2)), Sp2 = round(rnorm(5, 10, 3)), Sp3 = round(rnorm(5, 10, 2))) 

rownames(Large) <- c("Sample1", "Sample2", "Sample3", "Sample4", "Sample5" )

Small <- data.frame(Sp1 = round(rnorm(5, 50, 5)), Sp2 = round(rnorm(5, 50, 5)), Sp3 = round(rnorm(5, 50, 5))) 

rownames(Small) <- c("Sample1", "Sample2", "Sample3", "Sample4", "Sample5" )

```

```{r, echo=FALSE}
Large
Small
```


Общее обилие 
```{r}
Large + Small
```


##Простое умножение 
Умножение на число
```{r}
A * 4
```

Простое умножение матрицы на вектор возможно только если число элементов в векторе равно числу строк в матрице

```{r}
A * c(10, 11, 12, 13)

```

Все элементы первой строки матрицы умножаются на первый элемент вектора, все элементы второй строки на второй элемент вектора и т.д.  


##Биологическое применение
Допустим, учет организмов в части описаний проходил не на всей выборке, а лишь в ее части.
```{r}
Rpocessed_portion <- c(1, 1, 1/2, 1/3, 1/4)
Processed_Factor <- 1/Rpocessed_portion
```

```{r}
Small * Processed_Factor
```

## Длина вектора 

Длина вектора, или норма вектора

$$
||\textbf{b}|| = \sqrt{b_1^2 + b_2^2 + \dots + b_n^2}
$$

Нормализованный вектор
$$
\textbf{c} = \textbf{b} \cdot 1/||\textbf{b}||
$$

##Задание 
Найдите нормализованный вектор для следующего вектора
```{r}
Vec <- 1:5
Vec
```

##Решение
```{r}
Vec/sqrt(sum(Vec^2))

Vec/norm(t(Vec), type = "F")
```



##  Скалярное произведение векторов   
Допустимо только для векторов одинаковой размерности

$$
\textbf{a} \bullet \textbf{b} =  
\begin{pmatrix}
a_1 \\
a_3 \\    
a_4 \\
a_5 \\
a_6 \\
a_7
\end{pmatrix}
\times
\begin{pmatrix}
b_1 &
b_3 &    
b_4 &
b_5 &
b_6 &
b_7
\end{pmatrix}
= x
$$

Результат этой операции - число (скаляр)


##Биологическое применение
Сколько особей родится в популяции, если мы знаем репродуктивные характеристики всех возрастных групп?
$$
\begin{pmatrix}
N_1 \\
N_3 \\    
N_4 \\
N_5 \\
N_6 \\
N_7
\end{pmatrix}
\times
\begin{pmatrix}
F_1 & F_2 & F_3 & F_4 & F_5 & F_6 & F_7
\end{pmatrix}
$$

```{r}
N <- c(20, 40, 32, 45, 80, 50, 10)
Fert <- c( 0,  0,   1,   2,   2,   0,   0)

t(N) %*% (Fert)


```


##Умножение матриц
Умножать можно только в том случае, если число строк одной матрицы равно числу столбцов другой матрицы

```{r}
A %*% B
  ```

```{r}
A %*% t(A)
```


НО! Нельзя произвести такое умножение
```{r, eval=FALSE}
A %*% A
```




##Биологическое применение
Простейший пример использования умножения матрц - построение модели динамики демографической структуры популяции
Для вычислений необходим начальный *демографический вектор* и *матрица Лесли*

$$
\begin{pmatrix}
F_1 & F_2 & F_3 & F_4 & F_5 & F_6 & F_7 \\
P_{1-2}& 0 & 0 & 0 & 0 & 0 & 0 \\    
0 & P_{2-3} & 0 & 0 & 0 & 0 & 0 \\    
0 & 0 & P_{3-4} & 0 & 0 & 0 & 0 \\    
0 & 0 & 0 & P_{4-5} & 0 & 0 & 0 \\    
0 & 0 & 0 & 0 & P_{5-6} & 0 & 0 \\    
0 & 0 & 0 & 0 & 0 & P_{6-7} & 0     
\end{pmatrix}
\times
\begin{pmatrix}
N1_t \\
N3_t \\    
N4_t \\
N5_t \\
N6_t \\
N7_t
\end{pmatrix}
=
\begin{pmatrix}
N1_{t+1} \\
N3_{t+1} \\    
N4_{t+1} \\
N5_{t+1} \\
N6_{t+1} \\
N7_{t+1}
\end{pmatrix}
$$

##Простейшая демографическая модель


```{r, echo=FALSE}
T1 <- c(20, 40, 32, 45, 80, 50, 10)
Age <- c("0", "1-10", "11-20", "21-35", "36-45", "46-55", "56-65")
Pop <- data.frame(Age, T1)
```

Демографический вектор в момент времени $t$ 
```{r, echo=FALSE}
Pop
```

Матрица Лесли
```{r, echo=FALSE}
Lesl <- matrix(
c( 0,  0,   1,   2,   2,   0,   0,
  0.6, 0,   0,   0,   0,   0,   0,
   0,  0.7, 0,   0,   0,   0,   0, 
   0,  0,   0.8, 0,   0,   0,   0,
   0,  0,   0,   0.7, 0,   0,   0,
   0,  0,   0,   0,   0.6, 0,   0,
   0, 0,    0,   0,   0,  0.2, 0  ),
byrow = T, 
ncol = 7)
Lesl
```

## Демографическая струкутра в момент времени $t+1$ {.smaller .columns-2}


```{r}
Pop$T2 <- as.vector( Lesl %*% (Pop$T1 ))
Pop$T3 <- as.vector( Lesl %*% (Pop$T2 ))
Pop$T4 <- as.vector( Lesl %*% (Pop$T3 ))
Pop$T5 <- as.vector( Lesl %*% (Pop$T4 ))
Pop$T6 <- as.vector( Lesl %*% (Pop$T5 ))
Pop$T7 <- as.vector( Lesl %*% (Pop$T6 ))
Pop$T8 <- as.vector( Lesl %*% (Pop$T7 ))
Pop$T9 <- as.vector( Lesl %*% (Pop$T8 ))
Pop$T10 <- as.vector( Lesl %*% (Pop$T9 ))

```

```{r, echo=FALSE, message=FALSE}
library(ggplot2)
library(reshape)
Pop2 <- melt(Pop)
ggplot(Pop2, aes(x=Age, y = value)) + geom_bar(stat = "identity") + facet_wrap(~variable, ncol = 2) + labs(x = "Возраст", y = "Число особей")
```


##Некоторые свойства произведения матриц
1) Если существует произведение матриц $\textbf{BC}$, то не обязательно существует $\textbf{CB}$

```{r}
B <- matrix(1:24, ncol = 4)
C <- matrix(1:12, ncol = 3)

B %*% C
```

HO! 

```{r, eval=FALSE}

C %*% B
```

Такое произведение невозможно

##Некоторые свойства произведения матриц
2) Всегда существует такое произведение матриц $\textbf{CС'}$ и $\textbf{C'С}$

```{r}
C %*% t(C)
```

```{r}
t(C) %*% C
```


##Некоторые свойства произведения матриц
3) Произведение матриц $\textbf{BC}$ как правило не равно $\textbf{CB}$
```{r}
B <- matrix(1:9, ncol = 3)
C <- matrix(11:19, ncol = 3)

B %*%  C

C %*% B
```

##Некоторые свойства произведения матриц
4)  $[\textbf{BC}]' = \textbf{C}'\textbf{B}'$
```{r}
t(B %*% C)
```

```{r}
t(C) %*% t(B)
```

##Некоторые свойства произведения матриц
5)  Произведение $\textbf{BB'}$ и $\textbf{B'B}$ всегда дает симметричную матрицу 

```{r}
B %*% t(B)
```

```{r}
t(B) %*% B

```






##Обращение (инверсия) матриц {.smaller .columns-2}

В матричной алгебре нет процедуры деления. Вместо нее используют обращение матриц.

$$
\textbf{X}^{-1}\textbf{X} = \textbf{I}
$$


Обратить можно только такую матрицу, у которой определитель не равен нулю $$|\textbf{X}| \ne 0$$

Матрицы, у которых определитель $|\textbf{X}| = 0$ называются *сингулярными* матрицами они не могут быть инвертированы.

**Важное свойство**: Только квадратные матрицы имеют одну единственную обратную матрицу. 

Поэтому для квадратных матриц справедливо $\textbf{X} \textbf{X}^{-1} = \textbf{X}^{-1} \textbf{X}$

##Решение в среде R
Создадим матрицу
```{r, echo=FALSE}
X <- matrix(c(seq(1, 8),10), nrow = 3, byrow = T)
X
```

Ее определитель
```{r}
det(X)
```

##Решение в среде R
Обратная матрица 
```{r}
solve(X)

```

По определению $\textbf{X}^{-1}\textbf{X} = \textbf{I}$
```{r}
round(solve(X) %*% X )
```


##Примнение обратных матриц {.smaller}

Простейший случай использования обратных матриц - решение систем линейных уравнений
$$
\begin{cases}
1x + 2y + 3z = 2\\  
4x + 5y + 6z = 4 \\  
7x + 8y + 10z = 10   
\end{cases}
$$

Эту стстему можно представить в матричном виде

$$
\begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 10
\end{pmatrix}
\begin{pmatrix}
x \\ y \\ z
\end{pmatrix}
=
\begin{pmatrix}
2 \\ 4 \\ 10
\end{pmatrix}
$$

Тогда 

$$
\begin{pmatrix}
x \\ y \\ z
\end{pmatrix}
=
\begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 10
\end{pmatrix}
^{-1}
\begin{pmatrix}
2 \\ 4 \\ 10
\end{pmatrix}
$$

##Задание 
Решите приведенную систему уравнений с использованием матричной алгебры 



##Решение

```{r}
Coef <- matrix(c(1 , 2 , 3 ,
         4 , 5 , 6 ,
         7 , 8 , 10), byrow = T, ncol = 3)
Val <- c(2,4,10)

solve(Coef) %*% Val

```


##Подбор параметров линейной регрессии


При подборе коэффициентов методом нименьших квадратов нам надо решить следующее матричное уравнение:
$$
\textbf{y} =  \textbf{X} \pmb{\beta}
$$


Здесь  

$\textbf{y}$ - вектор предсказанных значений      

$\textbf{X}$ - модельная матрица  $\begin{pmatrix} 1 & x_1  \\ 1 & x_2 \\ \vdots & \vdots \\ 1 & x_n \end{pmatrix}$   

$\pmb{\beta}$  - вектор коэффициентов модели

##Решение этого уравнения   

Умножим обе части уравнения на транспонированную матрицу $\textbf{X}'$  

$$ \textbf{X}'  \textbf{y} = \textbf{X}'\textbf{X} \pmb{\beta}$$

Матрица $\textbf{X}'\textbf{X}$ - это всегда квадратная матрица. Ее можно обратить.

Тогда
$$
\pmb{\beta} = [\textbf{X}'\textbf{X}]^{-1}[\textbf{X}'\textbf{y}]
$$

##Подбор коэффициентов линейной регрессии вручную
Подбираем коэффициенты с помощью фунции `lm()`
```{r}
data(cars)
Mod <- lm(dist ~ speed, data = cars)
coefficients(Mod)
```

Подбираем коэффициенты вручную

```{r}
X <- data.frame(Int = 1, x = cars$speed)
X <- as.matrix(X)

y <- cars$dist
solve(t(X) %*% X) %*% (t(X) %*%y)

d <- solve(t(X) %*% X)
```


#Сингулярное разложение матриц (Singular value decomposition)

##Теорема Экарта-Янга {.smaller}
Любую прямоугольную матрицу $\textbf{Y}$ можно представить в виде произведения трех матриц: 

$$
\textbf{Y}_{n \times p} = \textbf{U}_{n \times p} \textbf{D}_{p \times p} \textbf{V}'_{p \times p} 
$$

То есть можно найти три "вспомогательных" матрицы, через котрые можно выразить любую другую матрицу. 

Здесь    

$\textbf{Y}_{n \times p}$ - любая прямоугольная матрица $\begin{pmatrix}a_{11} & a_{12} & \cdots & a_{1c} \\ a_{21} & a_{22} & \cdots & a_{2p} \\  \vdots & \vdots & \ddots & \vdots \\ a_{r1} & a_{n2} & \cdots & a_{np} \end{pmatrix}$   

$\textbf{D}_{p \times p}$ - диагональная матрица $\begin{pmatrix} d_{11} & 0 & \cdots & 0 \\ 0 & d_{22} & \cdots & 0 \\ \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & \cdots & d_{pp} \end{pmatrix}$

По главной диагонали располагаются "особые" числа, называющиеся **сингулярными числами**. Сингулярные числа ранжируются от большего к меньшему.

$\textbf{U}_{n \times p}$ и $\textbf{V}_{p \times p}$ - левая и правая матрицы сингулярных векторов.

## Сингулярное разложение матрицы средствами R
```{r}
set.seed(12345)
B <- matrix(round(runif(50, 1, 5))  , byrow = T, ncol=5) #Некоторая матрица
SVD <- svd(B) #Сингулярное Разложение матрицы B с помощью функции svd()
V <- SVD$v #"Вспомогательная" матрица - левые сингулярные вектора
D <- SVD$d #Вектор сингулярных чисел
U <- SVD$u #"Вспомогательная" матрица - правые сингулярные вектора 


```

Вычислим $\textbf{V} \textbf{D} \textbf{U}'$

```{r}
U %*% diag(D) %*% t(V) 
```

## Задание

Вычислите матрицу, которая получится при использовании только 1 и 2 сингулярного числа для матрицы $\textbf{B}$, использованной на предыдущем слайде.


##Решение
```{r}
U[,1:2] %*% diag(D[1:2]) %*% t(V[,1:2]) 

```


##Важное свойство сингулярных чисел

Если вычислить матрицу на основе не всех, а части сингулярных чисел, то новая матрица будет подобна исходной матрице.


```{r, echo=FALSE}
library(ggplot2)
Dat <- data.frame(Init = rep(as.vector(B), 4), SingValue = rep(2:5, each = length(as.vector(B))), Calc = c(as.vector((U[,1:2] %*% diag(D[1:2]) %*% t(V[,1:2]))), as.vector((U[,1:3] %*% diag(D[1:3]) %*% t(V[,1:3]))), as.vector((U[,1:4] %*% diag(D[1:4]) %*% t(V[,1:4]))), as.vector((U[,1:5] %*% diag(D[1:5]) %*% t(V[,1:5]))))) 

ggplot(Dat, aes(x = Init, y = Calc)) + geom_point(size = 2) + labs(x = "значения в исходной матрицы", y = "значения в редуцированной матрице") + facet_wrap(~SingValue) + geom_abline(slope = 1)  

```


## Применение свойства сингулярных чисел в сжатии изображений
Пример взят из курса лекций "Data Analysis" by Jeffrey Leek (https://github.com/jtleek/dataanalysis/tree/master/week3)

```{r,echo=FALSE}
load("data/face.rda")
gg_face <- function(x) {
  library(reshape)
  library(ggplot2)
    rotate <- function(x) t(apply(x, 2, rev))
  dd <- rotate(x)
  ddd <- melt(dd)
  ggplot(ddd, aes(X1, X2)) + geom_tile(aes(fill = value)) + scale_fill_gradient(low = "darkblue",   high =  "white" )
}
gg_face(faceData)

```

## Произведем сингулярное разложение матрицы `faceData` {.smaller}

```{r}
SVD_face <- svd(faceData)

U <- SVD_face$u
D <- SVD_face$d
V <- SVD_face$v

reduction <- function(x) U[,1:x] %*% diag(D[1:x]) %*% t(V[, 1:x])

gg_face(reduction(4))
```

##Применение SVD в биологических исследованиях

SVD - это метод, на котором основаны разные типы анализа, связанные со снижением размерности: PCA, CCA.

О них в следующей лекции

##Summary
- Матричная алгебра позволяет решать самые разные типы задач.
- Матричные методы лежат в основе очень многих типов анализа.
- В основе многих методов снижения размерности лежит SVD.

##Что почитать
* Legendre P., Legendre L. (2012) Numerical ecology. Second english edition. Elsevier, Amsterdam. Глава 2. Matrix algebra: a summary.

# Not The End
![alt text](images/matrix.jpg)

