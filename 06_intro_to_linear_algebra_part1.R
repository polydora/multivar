#' title: "Краткое введение в мир линейной алгебры. Часть 2"
#' subtitle: "Анализ и визуализация многомерных данных с использованием R"
#' author: Вадим Хайтов, Марина Варфоломеева


###########################################################
# Level 1: Немного повторения: Зоопарк матричных объектов #
###########################################################


A <- matrix(1:12, ncol = 3)

A %*% t(A)


det(A %*% t(A))

solve(A %*% t(A))


A * t(A)




diag(rep(1, 5))

diag(1:5)


###############################################################################
# Level 2: Еще немного повторения: Простейшие операции с матричными объектами #
###############################################################################

#' ##Транспонирование матриц
A <- matrix(1:12, ncol = 3)
A

B <- t(A)
B

#' ##Сложение матриц

A + 4

A + A

#' Но! Нельзя складывать матрицы разных размеров
A + B

#' ##Простое умножение

A * 4

#' Простое умножение матрицы на вектор возможно только если число элементов в векторе равно числу строк в матрице

A * c(10, 11, 12, 13)


######################################################
# Level 3: Векторы и их геометрическая интерпретация #
######################################################


# Длина вектора

Vec <- 1:5

sqrt(sum(Vec^2))

norm(t(Vec), type = "F") #Аналогчное решение


norm(t(Vec), type = "F") #Аналогчное решение

#' ##  Скалярное произведение векторов

#'
#' В доме есть следующие электроприборы.
#'
#' Электроприбор | Количество | Мощность (Вт) |
#' --------------|------------|---------------|
#' Чайник        | 2 шт       |       1200    |
#' Обогреватели  | 3 шт.      |    1300       |
#' Осушитель     | 1 шт.      |     1100 |
#' Стиральная машина | 1 шт.| 1500 |
#' Фен | 2 шт. | 800 |
#'
#' Вопрос: Какова будет суммарная мощность всех электроприборов, если их включить одновременно?
#'
#' ## Решение

n <- c(2, 3, 1, 1, 2)
power <- c(1200, 1300, 1100, 1500, 800)


# Решение

n  %*% power


#' ## Задание
#'
#' Выясните, являются ли ортогональными следующие векторы?

a <- c(0, 1)
b <- c(1, 0)

a %*% b

c <- c(1, 1)
d <- c(1, -1)

#' Аналитическое решение

a %*% c

c %*% d

a %*% d


#' ## Нормализованные векторы
#' ##Задание
#' Найдите нормализованный вектор для следующего вектора и определите его длину

Vec <- 1:5
Vec

#' ##Решение



### Коэффициент корреляции - косинус угла

## Создаем два скоррелированных вектора

set.seed(12345)
vec_1 <- rnorm(100, 10, 1)
vec_2 <- -10*vec_1 + 10 + rnorm(100, 0, 10)

library(ggplot2)

qplot(vec_1, vec_2)

cor(vec_1, vec_2)

# Цетрируем векторы
vec_1_c <- as.vector(scale(vec_1, center = T, scale = F))

# vec_1 - mean(vec_1)

vec_2_c <- as.vector(scale(vec_2, center = T, scale = F))


# Напишите код для вчисления косинуса угла

cos_alpha <- (vec_1_c %*% vec_2_c) / (norm(t(vec_1_c), type = "F") * norm(t(vec_2_c), type = "F"))

cos_alpha

Vec <- 1:5

Vec_norm <- Vec/norm(t(Vec), type = "F")




#########################################################
# Level 4: Еще немного повторения: Операции с матрицами #
#########################################################

#' ## Матричное умножение матрицы на вектор {.smaller .columns-2}

#' Пусть, есть матрица
A
# Матричное умножение на вектор
A %*% c(10, 10, 10)



#' Но! если поменять местами множители, то будет ошибка
c(10, 10, 10) %*% A



#' ## Матричное умножение вектора на матрицу

c(10, 10, 10, 10) %*% A

A %*% c(10, 10, 10, 10)





#' ##Умножение матриц {.smaller .columns-2}
A

B

B %*% A

A %*% A

B %*% t(B)





#'
#' ## Зачем это нужно?  {.smaller .columns-2}
#' ### Бытовой пример
#' Представим себе, что вы решили купить четыре товара, по следующим ценам
#'
#' Товар | Цена
#' ------|-----
#' Товар 1 | 10
#' Товар 2 | 20
#' Товар 3 | 30
#' Товар 4 | 40
#'
#'
#'
#' Прямых выходов на продавца у вас нет, но есть три посредника, которые выставляют следующие "накрутки" цен.
#'
#' Посредники  | Товар 1 | Товар 2 | Товар 3 | Товар 4
#' ------------|---------|---------|---------|--------
#' Посредник 1 | 0.1     | 0.15    | 0.05    | 0.05
#' Посредник 2 | 0.15    | 0.15    | 0.09    | 0.01
#' Посредник 3 | 0.2     | 0.05    | 0.1     | 0.1



# Какой из посредников выгоднее?
#' ## Решение

cost <- c(10, 20, 30, 40)

retailer <- matrix(c(0.1, 0.15, 0.05, 0.05,
                     0.15, 0.15, 0.09, 0.01,
                     0.2, 0.05, 0.1, 0.1 ), byrow = TRUE, ncol = 4)






itog1 <- cost %*% t(retailer)

itog2 <- retailer %*% cost





##################################################
# Level 5.Матрицы, как инструмент преобразования #
##################################################

#' ## Матрицы позволяют преобразовывать системы векторов
#'
#' Начальная система расположения точек
#'



y = c(2,2,3,3,2,2,3,4,5,6,6,5,4,3,2)
x = c(2,3,4,5,6,7,7,7,6,5,4,3,2,2,2)

Image <- cbind((x), (y))

library(ggplot2)
qplot(Image[,1], Image[,2] ) + geom_polygon(fill = "red") + coord_fixed()

Matr <- as.data.frame(t(cbind((x), (y))))
Matr



#' Поворот изображения на заданный угол

angle <- 35*pi/180

Rot <- matrix(c(cos(angle), sin(angle),
                -sin(angle), cos(angle)), nrow = 2)

Image_trans <-   t((Rot) %*% t(Image))


qplot(Image_trans[,1], Image_trans[,2] ) +
  geom_polygon(fill = "red") + coord_fixed()









#' Масштабирующая матрица
Scale <- matrix(c(1, 0, 0, 1), nrow = 2)

Image_trans2 <-   t((Scale) %*% t(Image_trans))

qplot(Image_trans2[,1], Image_trans2[,2] ) +
  geom_polygon(fill = "red") + coord_fixed()

M <- matrix(c(1,2,3,4,5,5,2,1,2,5,2,1,3,5,4,6,8,4,0,2), ncol = 4)
M




####################################################
# Level 6: Корреляционные и ковариационные матрицы #
####################################################



#' ## Ковариационная матрица

M <- matrix(c(1,2,3,4,5,5,2,1,2,5,2,1,3,5,4,6,8,4,0,2), ncol = 4)
M

#' Матрица центрированных значений
Cent_M <- scale(M, center = TRUE, scale = FALSE)
Cent_M


cov(M)

#' Вычислите ковариационную матрицу с помощью методов линейной алгебры и сравните ее с матрицей, полученной с помощью функции `cov()`

Cov_M <- ( t(Cent_M) %*% Cent_M ) / (nrow(Cent_M) - 1)



  #код для вычислению ковариационной матрицы с помощью матричной алгебры

cov(M)

diag(Cov_M)

#' Сравним с результатами применения функции sd()

apply(M, 2, FUN = function(x)sd(x)^2)

#' ## Вычисление матрицы  корреляций с помощью линейной алгебры {.smaller .columns-2}

cor(M)

Stand_M <- scale(M, center = T, scale = T)

Cor_M <- (t(Stand_M) %*% Stand_M) / (nrow(Stand_M) - 1)

# Вычисление вручную
Cor_M <-



cor(M) # Стандартная функция R





################################################################
# Level 7: Еще немного повторения: Обращение (инверсия) матриц #
################################################################

X <- matrix(c(1:8, 10), ncol = 3,  byrow = T)

# Найдите и интерпретируйте определитель этой матрицы


# найдите инверсию этой матрицы


# Найдите произведеине исходной матрицы и ее инверсии





