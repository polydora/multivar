<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>(Геометрическая) морфометрия</title>
    <meta charset="utf-8" />
    <meta name="author" content="Марина Варфоломеева" />
    <script src="site_libs/header-attrs-2.20.1/header-attrs.js"></script>
    <link href="site_libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="site_libs/remark-css-0.0.1/tamu-fonts.css" rel="stylesheet" />
    <link href="site_libs/remark-css-0.0.1/ninjutsu.css" rel="stylesheet" />
    <link href="site_libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="site_libs/tile-view-0.2.6/tile-view.js"></script>
    <script src="site_libs/fabric-4.3.1/fabric.min.js"></script>
    <link href="site_libs/xaringanExtra-scribble-0.0.1/scribble.css" rel="stylesheet" />
    <script src="site_libs/xaringanExtra-scribble-0.0.1/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30,"palette":[]}) })</script>
    <script src="site_libs/mark.js-8.11.1/mark.min.js"></script>
    <link href="site_libs/xaringanExtra-search-0.0.1/search.css" rel="stylesheet" />
    <script src="site_libs/xaringanExtra-search-0.0.1/search.js"></script>
    <script>window.addEventListener('load', function() { window.xeSearch = new RemarkSearch({"position":"bottom-left","caseSensitive":false,"showIcon":false,"autoSearch":true}) })</script>
    <script src="site_libs/xaringanExtra-progressBar-0.0.1/progress-bar.js"></script>
    <script src="site_libs/freezeframe-5.0.2/freezeframe.min.js"></script>
    <script src="site_libs/xaringanExtra-freezeframe-0.0.1/freezeframe-init.js"></script>
    <script id="xaringanExtra-freezeframe-options" type="application/json">{"selector":"img[src$=\"gif\"]","trigger":"click","overlay":false,"responsive":true,"warnings":true}</script>
    <link href="site_libs/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <!-- https://github.com/fnaufel/xaringan-smartify-->
    <script
    			  src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
    			  integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8="
    			  crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/fnaufel/xaringan-smartify/smartify.min.js"></script>
    <link rel="stylesheet" href="assets/xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="assets/xaringan.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: middle, left, inverse, title-slide

.title[
# (Геометрическая) морфометрия
]
.subtitle[
## Анализ и визуализация многомерных данных с использованием R
]
.author[
### Марина Варфоломеева
]

---






## Анализ морфометрических данных при помощи анализа главных компонент

- Классический подход к морфометрии
- Геометрическая морфометрия
- Эволюция формы

### Вы сможете

- Проанализировать морфометрические данные корректно удалив влияние абсолютного размера
- Рассказать, что происходит во время обобщенного прокрустова анализа
- Проанализировать данные о координатах меток используя методы геометрической морфометрии
- Понимать, каким образом происходит отображение филогенетического древа в пространство форм

---

class: middle, center, inverse

# Классический подход к морфометрии

---

## Классический подход к морфометрии

Для анализа формы различных структур анализируются расстояния между метками, а не их координаты.

Признаки сильно интегрированных структур, например частей скелета, лучше анализировать совместно друг с другом. Один из вариантов анализа - анализ главных компонент.

---

## Пример: морфометрия черепах

Черепахи - единственные живые представители анапсид (череп не имеет височных окон). Морфология черепа важна для их систематики (Claude et al., 2004).

Данные - 24 разных измерения черепов черепах 122 ныне живущих пресноводных, морских и наземных видов и одного ископаемого.

![Морфометрия черепах](images/Fig30.1ZuurAED-mod.jpg)

&lt;div class = "footnote"&gt;Рис. 30.1 из Zuur et al. 2007&lt;/div&gt;

---

## Читаем данные


```r
turt &lt;- read.table("data/turtles.txt", header = TRUE)
turt$Environment3 &lt;- factor(turt$Environment3, levels = c(0, 1, 2, 9),
          labels = c("Freshwater", "Terrestrial", "Marine", "Fossil"))
colnames(turt)
```

```
 [1] "nspecies"     "species_name" "Family"       "SuperFamily"  "Order"       
 [6] "Environment"  "Environment3" "D1"           "D2"           "D3"          
[11] "D4"           "D5"           "D6"           "D7"           "D8"          
[16] "D9"           "D10"          "D11"          "D12"          "D13"         
[21] "D14"          "D15"          "D16"          "D17"          "D18"         
[26] "D19"          "D20"          "D21"          "D22"          "D23"         
[31] "D24"         
```

.pull-down[.tiny[Данные из Zuur et al. 2007]]

---

## Чтобы понять, нужно ли стандартизовать исходные данные, построим боксплот


```r
boxplot(x = turt[8:31])
```

![](08.2_PCA_geometric_morphometrics_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

--

- Наверное, лучше стандартизовать

---

## Делаем анализ главных компонент по стандартизованным данным


```r
library(vegan)
turt_pca &lt;- rda(turt[, 8:31], scale = TRUE)
```

---

## Сколько компонент достаточно для описания данных?


```r
eig &lt;- eigenvals(turt_pca)[1:5]
eig*100/sum(eig) # доля объясненной изменчивости
```

```
   PC1    PC2    PC3    PC4    PC5 
86.760  6.936  3.074  1.956  1.273 
```

```r
screeplot(turt_pca, bstick = TRUE)
```

![](08.2_PCA_geometric_morphometrics_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

--

- Первая компонента объясняет очень много, остальные - почти ничего. Одной компоненты достаточно?
- Нет! Не все так просто.

---

## Что странного в этой картинке?


```r
biplot(turt_pca, display = "species", scaling = 2)
```

![](08.2_PCA_geometric_morphometrics_files/figure-html/biplot-raw-1.png)&lt;!-- --&gt;

- Как вы думаете, почему у всех переменных большие нагрузки по первой компоненте?

- Что отражает первая компонента?

---

## При анализе сырых морфометрических данных первая компонента отражает размер объектов и, возможно, немножко - их форму

![](08.2_PCA_geometric_morphometrics_files/figure-html/biplot-raw-1.png)&lt;!-- --&gt;

---

## Классические способы избавиться от влияния размера:

- использовать одну из исходных переменных как оценку "размера": использовать в PCA остатки от регрессий исходных признаков от "размера"
- стандартизация исходных данных при помощи деления на величину "размера" для каждого образца (корень из суммы квадратов измерений)
- сделать двойное центрирование (логарифмированных) исходных данных
- и т.д. и т.п.

---

## Двойное центрирование

Нам достаточно центрировать строки, т.к. столбцы будут центрированы автоматически в процессе анализа главных компонент.


```r
# Функция, которая может центрировать вектор
center &lt;- function(x){
  x - mean(x, na.rm = TRUE)
}
# применяем эту функцию к каждой строке
dbcent &lt;- t(apply(turt[, 8:31], 1, center))
# получившийся датафрейм пришлось транспонировать,
# поскольку apply() результаты от каждой строки
# возвращает в виде столбцов
```

---

## После двойного центрирования большие собственные числа у нескольких компонент


```r
turt_db_pca &lt;- rda(dbcent)
eig_db &lt;- eigenvals(turt_db_pca)[1:5]
eig_db*100/sum(eig_db)
```

```
   PC1    PC2    PC3    PC4    PC5 
65.477 23.121  6.362  3.125  1.915 
```

```r
screeplot(turt_db_pca, bstick = TRUE)
```

![](08.2_PCA_geometric_morphometrics_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;

---

## После двойного центрирования у переменных высокие нагрузки на несколько компонент, влияние размера удалено


```r
biplot(turt_db_pca, display = "species", scaling = 2)
```

![](08.2_PCA_geometric_morphometrics_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;

Интерпретируем как обычно: компонента отражает несколько признаков

---

## Ординация черепах по морфометрии черепов (двойное центрирование данных)

![](08.2_PCA_geometric_morphometrics_files/figure-html/tradit-pca-1.png)&lt;!-- --&gt;

- У пресноводных большие D12 и D13, и маленькая D2. У морских наоборот
- Ископаемая черепаха похожа на нынешних морских

---

## Код для графика ординации черепах по морфометрии черепов


```r
op &lt;- par(mfrow = c(1, 2), mar = c(4, 4, 0.5, 0.5), cex = 1.3)
biplot(turt_db_pca, display = "species", scaling = 2)
# цвета для графика факторных координат
colvec &lt;- c("orange2", "limegreen", "steelblue", "red3")
# пустой график
plot(turt_db_pca, type = "n", scaling = 1)
# точки, раскрашенные по уровням фактора turt$Environment3
points(turt_db_pca, display = "sites", scaling = 1, pch = 21, 
       col = colvec[turt$Environment3], bg = colvec[turt$Environment3])
# легенда
legend("bottomright", legend = levels(turt$Environment3), bty = "n", pch = 21, 
       col = colvec, pt.bg = colvec)
par(op)
```

---

class: middle, center, inverse

.pull-right[
Но настоящие джедаи теперь анализируют координаты меток, а не расстояния между ними!
]

# Геометрическая морфометрия



---

## Пример: Форма головы Апалачских саламандр рода _Plethodon_

_Plethodon jordani_ и _P.teyahalee_ встречаются вместе и раздельно.
В совместно обитающих популяциях меняется форма головы обоих видов. В разных группах популяций этот процесс параллельно приводит к одинаковым результатам. По-видимому, одной из причин параллельной эволюции может быть межвидовая конкуренция (Adams, 2004, 2010).

.pull-left[

![_Plethodon jordani_](images/PlethodoJordaniJordansSalamander-JohnPClare-Flickr.jpg)

.tiny[_Plethodon jordani_ - Jordan's Salamander by [John P Clare on Flickr](https://flic.kr/p/dMfNq6)]
]

.pull-right[
![_Plethodon_ cf. _teyahalee_](images/PlethodonCfTeyahalee-squamatologist-Flickr.jpg)

.tiny[_Plethodon_ cf. _teyahalee_ by [squamatologist on Flickr](https://flic.kr/p/8m82g6)]
]

---

## Морфометрия головы саламандр

![Схема измерений](images/measurements-Adams2004.jpg)


```r
# install.packages("geomorph", dependencies = TRUE)
library(geomorph)
data(plethodon)
str(plethodon, vec.len = 2, give.attr = F)
```

```
List of 5
 $ land   : num [1:12, 1:2, 1:40] 8.89 9.27 ...
 $ links  : num [1:14, 1:2] 4 3 2 1 1 ...
 $ species: Factor w/ 2 levels "Jord","Teyah": 1 1 1 1 1 ...
 $ site   : Factor w/ 2 levels "Allo","Symp": 2 2 2 2 2 ...
 $ outline: num [1:3631, 1:2] 0.399 0.4 ...
```

.pull-down[.tiny[рис. из Adams, 2004, 2010]]

---

## Сырые морфометрические данные еще не выравнены

Все образцы разного размера и разной ориентации в пространстве. На этом графике --- два образца для примера.


```r
plotRefToTarget(plethodon$land[, , 1], plethodon$land[, ,10],
                method = "points", mag = 1, 
                links = plethodon$links)
```

![](08.2_PCA_geometric_morphometrics_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;

---

## Если нарисовать не выравненные образцы, получится полная каша. Что делать?

Слева - три образца, справа - все. Жирные точки - центроиды соответствующих меток


```r
op &lt;- par(mfrow = c(1, 2), mar = c(4, 4, 1, 1))
plotAllSpecimens(plethodon$land[, , 1:3], links=plethodon$links)
plotAllSpecimens(plethodon$land,links=plethodon$links)
par(op)
```

![](08.2_PCA_geometric_morphometrics_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;

---

## Геометрическая морфометрия

1. Влияние размера удаляется при помощи обобщенного прокрустова анализа (масштабирование, поворот и сдвиг координат)
1. Преобразованные координаты меток используются как признаки объектов (конкретных особей) в анализе главных компонент. Получается морфопространство. Главные компоненты отражают изменения формы.

- можно получить усредненную форму для любой группы выравненных координат
- можно сравнить форму любой особи со средней формой
- можно проследить изменение формы вдоль осей главных компонент

---

## Прокрустов анализ

![Прокрустово ложе](images/Theseus-Procrustes.jpg)

.small[Тезей убивает разбойника Прокруста (источник https://mrpsmythopedia.wikispaces.com/Procrustes)]

---

## Шаг 1. Выравниваем данные при помощи обобщенного прокрустова анализа

Generalized Procrustes Analysis (GPA)

Минимизируем сумму квадратов расстояний между одноименными метками, меняя масштаб, поворачивая и сдвигая координаты. Вот как это выглядит на данных про черепах:

![Прокрустово преобразование](images/Fig30.8ZuurAED-mod.jpg)

.pull-down[.small[Рис. 30.8 из Zuur et al. 2007 с изменениями]]

---

## Выравниваем головы саламандр


```r
gpa &lt;- gpagen(plethodon$land, print.progress = FALSE)
plotAllSpecimens(gpa$coords,links=plethodon$links)
```

![](08.2_PCA_geometric_morphometrics_files/figure-html/unnamed-chunk-11-1.png)&lt;!-- --&gt;

---

## Усредненная форма


```r
ref &lt;- mshape(gpa$coords) 
plotRefToTarget(ref, ref, method = "TPS", links = plethodon$links)
```

![](08.2_PCA_geometric_morphometrics_files/figure-html/unnamed-chunk-12-1.png)&lt;!-- --&gt;

---

## Можем посмотреть, как отличается любой из образцов от усредненной формы

Изменение формы можно представить графически несколькими способами

![](08.2_PCA_geometric_morphometrics_files/figure-html/comparis-1.png)&lt;!-- --&gt;

---

## Код для графиков сравнения образцов с усредненной формой


```r
# матрица, в которой хранится разметка общего графика
m &lt;- matrix(data = c(1, 2,
                     3, 3),
            nrow = 2, ncol = 2, byrow = TRUE)
l &lt;- layout(m, heights = c(1, 1), widths = c(1, 1))
# layout.show(l) # можно просмотреть разметку

# Графики
op &lt;- par( mar = c(0, 0, 0, 0))
# 1) изменение конфигурации обозначено векторами
plotRefToTarget(ref, gpa$coords[, , 11],
                method = "vector", mag = 1,
                links = plethodon$links)
# 2) формы обозначены точками
plotRefToTarget(ref, gpa$coords[, , 11],
                method = "points", mag = 1,
                links = plethodon$links)
# 3) сплайн
plotRefToTarget(ref, gpa$coords[, , 11],
                method = "TPS", mag = 1,
                links = plethodon$links)
par(op)
```

---

## Шаг 2. Создаем морфопространство

__Анализ главных компонент по координатам меток для выравненных образцов__. Главные компоненты отражают изменения формы.


```r
ord &lt;- gm.prcomp(gpa$coords)
plot(ord, main = "PCA")
```

![](08.2_PCA_geometric_morphometrics_files/figure-html/unnamed-chunk-13-1.png)&lt;!-- --&gt;

---

## Можно раскрасить по группам

![](08.2_PCA_geometric_morphometrics_files/figure-html/pca-p-1.png)&lt;!-- --&gt;

---

## Код для графика ординации и для легенды


```r
op &lt;- par(mar = c(4, 4, 1, 1), cex = 1.5)
# группа должна быть фактором
gp &lt;- as.factor(paste(plethodon$species, plethodon$site)) 

# задаем соответствие цветов уровням фактора
colvec &lt;- c("Jord Allo" = "yellow2", 
            "Jord Symp" = "orange", 
            "Teyah Allo" = "green4", 
            "Teyah Symp" = "green1")
# вектор цветов в порядке заданном фактором gp
colvec &lt;- colvec[match(gp, names(colvec))]
# график
plot(ord, bg = colvec, pch = 21, col = "grey20")
# легенда
legend("topright", legend = levels(gp), 
                   bty = "n", pch = 21, 
                   col = "grey20", 
                   pt.bg = levels(as.factor(colvec)))
par(op)
```

---

## Доля объясненной изменчивости и факторные координаты


```r
# Доля изменчивости объясненной 1-5 компонентами
expl &lt;- round(ord$d[1:5]/sum(ord$d) * 100, 1) 

# Факторные координаты по 1-5 компонентам
head(ord$x[, 1:5]) 
```

```
       Comp1   Comp2      Comp3     Comp4     Comp5
1 -0.0369931 0.05118 -0.0016972 -0.003129 -0.010936
2 -0.0007494 0.05942  0.0001372 -0.002769 -0.008118
3  0.0056005 0.07420 -0.0052612 -0.005035 -0.002747
4 -0.0134808 0.06464 -0.0458436 -0.007887  0.009817
5 -0.0334696 0.06864  0.0136292  0.007359  0.022347
6 -0.0052145 0.06163 -0.0299333 -0.005753 -0.024060
```

---

## Чтобы легко рисовать изменения формы вдоль главной компоненты нам понадобится функция


```r
plot_shape_change &lt;- function(ord, ref_shape, PC,
                              horiz = TRUE,
                              gridPars = NULL, ...){
  if(horiz){
    op &lt;- par(mfrow = c(1, 2), mar = c(0, 0 , 0, 0))
    plotRefToTarget(M1 = ref_shape, M2 = ord$shapes[[PC]]$min,
                    gridPars = gridPars,  ...)
    plotRefToTarget(M1 = ref_shape, M2 = ord$shapes[[PC]]$max,
                    gridPars = gridPars, ...)
    par(op)
    } else {
     op &lt;- par(mfrow = c(2, 1), mar = c(0, 0 , 0, 0))
     plotRefToTarget(M1 = ref_shape, M2 = ord$shapes[[PC]]$max,
                     gridPars = gridPars,  ...)
     plotRefToTarget(M1 = ref_shape, M2 = ord$shapes[[PC]]$min,
                     gridPars = gridPars, ...)
     par(op)
    }
}
```

---

## Изменение формы вдоль главных компонент относительно средней формы


```r
plot_shape_change(ord, ref_shape = gpa$consensus, PC = 1, 
                  links = plethodon$links, method = "TPS") 
```

![](08.2_PCA_geometric_morphometrics_files/figure-html/unnamed-chunk-16-1.png)&lt;!-- --&gt;


```r
plot_shape_change(ord, ref_shape = gpa$consensus, PC = 2, 
                  links = plethodon$links, method = "TPS", horiz = FALSE) 
```

![](08.2_PCA_geometric_morphometrics_files/figure-html/unnamed-chunk-17-1.png)&lt;!-- --&gt;

---

## Можно нарисовать одновременно изменение формы вдоль обеих компонент и ординацию

![](08.2_PCA_geometric_morphometrics_files/figure-html/forms-pca-p-1.png)&lt;!-- --&gt;


---

## Код для графика


```r
my_gridPar &lt;- gridPar(tar.pt.size = 0.6, grid.lwd = 0.7)
library(cowplot)
gg_pca &lt;- plot_grid(
  # Изменение формы вдоль PC2
  ~ plot_shape_change(ord, ref_shape = gpa$consensus, PC = 2,
                      horiz = FALSE, links = plethodon$links,
                      method = "TPS", gridPars = my_gridPar),
  # Ординация
  ~ {plot(ord, bg = colvec, pch = 21, col = "grey20", cex = 1.5)
    legend("topright", legend = levels(gp),  bty = "n", 
           pch = 21, col = "grey20", 
           pt.bg = levels(as.factor(colvec)))},
  # пустой график
  NULL,
  # Изменение формы вдоль PC1
  ~ plot_shape_change(ord, ref_shape = gpa$consensus, PC = 1,
                      links = plethodon$links, 
                      method = "TPS", gridPars = my_gridPar),
  # Параметры размещения
  ncol = 2, rel_heights = c(5, 1), rel_widths = c(1, 4)
)

gg_pca
```

---

class: middle, center, inverse


# Эволюционные изменения формы

---

## Фило-морфо пространство

Если у вас есть данные о средних формах для каждого вида и данные о филогении (из любого источника), то можно изобразить эволюционные изменения формы

Этапы:

1. Выравнивание средних форм для таксонов при помощи обобщенного прокрустова анализа
1. Ординация таксонов при помощи анализа главных компонент
1. Поиск анцестральных состояний количественных признаков (форм) методом максимального правдоподобия
1. Наложение филогенетического дерева и анцестральных форм на график ординации

---

## Фило-морфопространство саламандр рода Plethodon

P. serratus, P. cinereus, P. shenandoah, P. hoffmani, P. virginia, P. nettingi, P. hubrichti, P. electromorphus, P. richmondi


```r
data(plethspecies)
str(plethspecies, vec.len = 2, give.attr = F)
```

```
List of 2
 $ land: num [1:11, 1:2, 1:9] 0.217 0.259 ...
 $ phy :List of 4
  ..$ edge       : int [1:16, 1:2] 10 10 11 12 12 ...
  ..$ Nnode      : int 8
  ..$ tip.label  : chr [1:9] "P_serratus" "P_cinereus" ...
  ..$ edge.length: num [1:16] 15.17 3.84 ...
```

---

## Выравниваем средние формы для видов


```r
species_gpa &lt;- gpagen(plethspecies$land) #GPA-alignment
```

```

Performing GPA

  |                                                                                   
  |                                                                             |   0%
  |                                                                                   
  |===================                                                          |  25%
  |                                                                                   
  |======================================                                       |  50%
  |                                                                                   
  |=============================================================================| 100%

Making projections... Finished!
```

---

## Наложение филогенетического дерева и анцестральных форм на график PCA ординации

Филоморфопространство


```r
pca_with_phylo &lt;- gm.prcomp(species_gpa$coords, phy = plethspecies$phy)
plot(pca_with_phylo, phylo = TRUE)
```

![](08.2_PCA_geometric_morphometrics_files/figure-html/unnamed-chunk-20-1.png)&lt;!-- --&gt;

---

## Take-home messages

- Классический подход к морфометрии
    - анализируют расстояния между метками
    - для корректного анализа необходимо удалить влияние размера и оставить форму, но сделать это корректно почти невозможно
- Геометрическая морфометрия
    - анализируют координаты меток
    - различные конфигурации выравнивают при помощи обобщенного прокрустова анализа
    - преобразованные координаты точек используют в анализе главных компонент
    - чтобы визуализировать эволюцию форм, можно наложить филогенетическое древо на ординацию

---

## Дополнительные ресурсы

- Bookstein, F.L., 2003. Morphometric Tools for Landmark Data Geometry and Biology. Cambridge University Press.
- Claude, J., 2008. Morphometrics With R. Springer.
- GEOL G562 - Geometric Morphometrics [WWW Document], n.d. URL http://www.indiana.edu/~g562/PBDB2013/ (accessed 4.1.15).
- Zelditch, M., Swiderski, D.L., Sheets, D.H., Fink, W.L., 2004. Geometric Morphometrics for Biologists. Academic Press.
- Zuur, A.F., Ieno, E.N., Smith, G.M., 2007. Analysing ecological data. Springer.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="assets/macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "vs",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<!-- https://github.com/fnaufel/xaringan-smartify-->
<script type="text/javascript">
  smartify();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
