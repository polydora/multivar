---
layout: page
title: Знакомство с R
---

# Комментарии

Комментарии в текстах программ обозначаются символом #

```{r}
# это комментарии, они не будут выполняться
```

# Полезные клавиатурные сокращения в RStudio

- `Ctrl + Shift + C` - закомментировать/раскомментировать выделенный фрагмент кода
- `Ctrl + Enter` - отправляет строку из текстового редактора в консоль, а если выделить несколько строк, то будет выполнен этот фрагмент кода.
- `Tab` или `Ctrl + Space` - нажмите после того как начали набирать название функции или переменной, и появится список автоподстановки. Это помогает печатать код быстро и с меньшим количеством ошибок.

# Устанавливаем рабочую директорию

Есть несколько способов установки пути к рабочей директории:

1. Выберите в меню Session -> Set working Directory... -> To Source File Location (Если вы уже сохранили код).
2. На вкладке Files в одной из рабочих областей RStudio выберите многоточие ... -> в открывшемся системном диалоге выбора файлов найдите директорию, в которой лежит ваш код и нажмите OK
3. Можно вручную прописать путь к рабочей директории в кавычках в качестве аргумента функции setwd

```{r eval=FALSE}
setwd("~/lect-linmodr/Intro")
```

# Как получить помощь

1. В RStudio можно поставить курсор на слово setwd и нажать F1
2. Перед названием функции можно напечатать знак вопроса и выполнить эту строку
?setwd
3. Можно воспользоваться функцией help()

```{r eval=FALSE}
help("setwd")
```

# R как калькулятор, математические операции

```{r}
2+2
1024/2
1:10
34*4
2^4
sqrt(27)
```

# Переменные

Оператор присваивания это символ стрелочки `<-`. Он работает справа налево, это значит, что значение выражения в его правой части присваивается объекту в левой части.

Переменные - это такие контейнеры, в которые можно положить разные данные и даже функции.


Имена переменных могут содержать латинские буквы обоих регистров, символы точки . и подчеркивания _ , а так же цифры. Имена переменных должны начинаться с латинских букв. Создавайте понятные и "говорящие" имена переменных.

```{r}
var_1 <- 1024 / 2
1238 * 3 -> var_2
var_2
```

Как выбрать название переменной?

- `a` - плохо, и даже `b`, `с`, или `х`. Но в некоторых случаях допустимо:)
- `var1` - плохо, но уже лучше
- `var_1` - плохо, но уже лучше
- `shelllength` - говорящее, но плохо читается
- `shell_length`, `wing_colour` или `leg_num` - хорошие говорящие и читабельные названия

# Структуры данных

Данные в R можно хранить в виде разных объектов.


В результате выполнения следующих команд получаются _скалярные величины_. Просто числа. Одно выражение - одно значение

```{r}
23
sqrt(25)
```

На самом деле, эти величины - просто векторы единичной длины

## Векторы

_Векторы_ - один объект, внутри которого несколько значений.

### Способы создания векторов:

- Оператор: используется для создания целочисленных векторов, где значения следуют одно за другим без пропусков

```{r}
1:10 # от одного до 10
-5:3 # от -5 до 3
```

- Функция `c()` - от англ. concatenate. Следите, чтобы было английское си, а не русское эс:).

```{r eval=FALSE}
?c # посмотрите хелп к функции
```

Функция `c` принимает несколько (произвольное количество) аргументов, разделенных запятыми. Она собирает из них вектор.

```{r}
c(2, 4, 6)
c(-9.3, 0, 2.17, 21.3)
```

Векторы можно хранить в переменных для последующего использования

```{r}
vect_num <- -11:12 # численный вектор от -11 до 12 сохранен в переменной vect_num
vect_num_1 <- c(1.3, 1.7, 1.2, 0.9, 1.6, 1.4) # численный вектор, сохранен в переменной vect_num_1
```

### Адресация внутри векторов

При помощи оператора `[]`, мужно обратится к некоторым элементам вектора. 
В квадратных скобках вам нужно указать один или несколько порядковых номеров элементов

```{r}
vect_num[1] # первый элемент в векторе vect_num
vect_num[10] # 10-й элемент
vect_num[22]
```

Если вам нужно несколько элементов, то их нужно передать квадратным скобкам в виде вектора. Например, нам нужны элементы с 3 по 5. Вот вектор, который содержит значения 3, 4 и 5.

```{r}
3:5
```

Если мы его напишем в квадратных скобках, то добудем элементы с такими порядковыми номерами

```{r}
vect_num[3:5]
```

Аналогично, если вам нужны элементы не подряд, то передайте вектор с номерами элементов, который вы создали при помощи функции c()
c(2, 4, 6) # это вектор содержащий 2, 4 и 6, поэтому

```{r}
vect_num[c(2, 4, 6)] # возвращает 2-й, 4-й и 6-й элементы
vect_num[c(1, 10, 20)] # возвращает 1-й, 10-й и 20-й элементы
```

Вектор - одномерный объект. У его элементов только один порядковый номер (индекс). Поэтому при обращении к элементам вектора нужно указывать только одно число или один вектор с адресами.

Правильно:

```{r}
vect_num[c(1, 2, 5)] # возвращает 1-й, 3-й и 5-й элементы
```

Но R выдаст ошибку, если при обращении к вектору, вы не создавали вектор, а просто перечислили номера элементов через запятую.

```{r eval=FALSE}
vect_num[1, 3, 5] # ошибка
vect_num[15, 9, 1] # ошибка
```
```{r}
vect_num[c(15, 9, 1)] # правильно
```


При помощи функции c() можно объединять несколько векторов и скаляров в один вектор

```{r}
c(1, 1, 5:9)
c(vect_num, vect_num)
c(100, vect_num)
```

Добываем 1, 3, 5 и с 22 по 24 элементы

```{r}
vect_num[c(1, 3, 5, 22:24)]
```

# Типы данных в R

## Числовые данные

только что видели

## Текстовые данные

Каждый текстовый элемент (говорят "строка" - string) должен быть окружен кавычками - двойными или одинарными

```{r}
"это текст"
'это тоже текст'
```

Текстовые значения можно объединять в вектора.

Это текстовый вектор

```{r}
rainbow <- c("red", "orange", "yellow", "green", "blue", "violet")
rainbow # весь вектор
```

Добываем первый и последний элементы

В данном случае я точно знаю, что их 6, мне нужны 1 и 6.

```{r}
rainbow[c(1, 6)]
```

Добываем элементы с 3 по 6

Если у вас вдруг слишком короткий вектор в этом задании, то можно склеить новый из двух

```{r}
double_rainbow <- c(rainbow, rainbow)
double_rainbow
rainbow[3:6] # элементы с 3 по 6
```

## Логические данные

```{r}
TRUE # истина
FALSE # ложь
```

Для ленивых - можно сокращать первыми заглавными буквами. Но лучше так не делать, чтобы читать программы было легче

```{r}
c(T, T, T, T, F, F, T, T)
```

Логический вектор

```{r}
c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)
```

Еще логический вектор

```{r}
short_logical_vector <- c(FALSE, TRUE)
```

Создаем длинный логический вектор.

Чтобы создавать длинные вектора из повторяющихся элементов, можно использовать функцию rep()

```
?rep
```

```{r}
rep(x = 1, times = 3) # 1 повторяется 3 раза
rep(x = "red", times = 5) # "red" повторяется 5 раз
rep(x = TRUE, times = 2) # TRUE повторяется 2 раза
```

В R названия аргументов функций можно не указывать, если вы используете аргументы в том же порядке, что прописан в help к этой функции.

```{r}
rep(TRUE, 5) # TRUE повторяется 5 раз, аргументы без названий
```

Создаем логический вектор, где TRUE повторяется 3 раза, FALSE 3 раза и TRUE 4 раза. Результат сохраняем в переменной vect_log

```{r}
vect_log <- c(rep(TRUE, 3), rep(FALSE, 3), rep(TRUE, 4))
vect_log
```


## Факторы

Факторы - это способ хранения дискретных (=категориальных данных). Например, если вы поймали 10 улиток и посмотрели их цвет. У большого количества улиток небольшое счетное количество возможных цветов.

```{r}
snail_colours <- c("red", "green", "green", "green", "yellow", "yellow", "yellow", "yellow")
snail_colours # это текстовый вектор.
```

Но цвет "желтый" обозначает одно и то же для каждой из улиток. Поэтому в целях экономии места можно записать цвета этих улиток в виде вектора, в котором численным значениям будут сопоставлены "этикетки" (называются "уровни" - levels) - названия цветов. Мы можем создать "фактор" цвет улиток.

```{r}
factor(snail_colours)
```

уровни этого фактора

- 1 - green,
- 2 - red,
- 3 - yellow

По умолчанию, R назначает порядок уровней по алфавиту. Можно изменить порядок (см. `help("factor")`). Нам это пригодится позже

```{r}
double_rainbow # текстовый вектор
```

Создаем фактор из текстового вектора и складываем его в переменную

```{r}
f_double_rainbow <- factor(double_rainbow)
```

## Как узнать, что за данные хранятся в переменной?

Чтобы узнать, что за данные хранятся в переменной, используйте функцию `class()`

```{r}
class(f_double_rainbow)
class(vect_log)
class(vect_num)
class(rainbow)
```


# Встроенные константы в R

Встроенные константы в R: NA, NULL, NAN, Inf

- NA - англ "not available". Когда объект был, но его свойство не измерили или не записали.
- NULL - пусто - просто ничего нет
- NaN - "not a number"
- Inf - "infinity" - бесконечность

Вот текстовый вектор с пропущенным значением

```{r}
rainbow_1 <- c("red", "orange", NA, "green", "blue", "violet")
```

Кстати, если попросили добыть из вектора номер элемента, которого там точно нет, то R выдаст NA, потому, что такого элемента нет

```{r}
rainbow_1[198]
```

Поэкспериментируем с векторами. Проверим, как работают арифметические операции

```{r}
vect_num + 2
vect_num * 2
vect_num * (-2)
vect_num ^2
```

Теперь посмотрим на встроенные константы в действии.

Создаем новый вектор для экспериментов

```{r}
NAs_NANs <- c(1, 3, NA, 7, 0, 22:24)
```

Вот так он выглядит

```{r}
NAs_NANs
```

Что произойдет с NA?

```{r}
NAs_NANs + 2 # останется NA
NAs_NANs * 0 # останется NA
NAs_NANs / 0  # останется NA
```

Но в последнем случае вы увидите 

- Inf при делении чисел на ноль
- NaN при делении нуля на ноль

NaN получится, если взять корень из отрицательного числа

```{r}
sqrt(-1)
```

# Функции в R

Вы уже видели массу функций, их легко узнать по скобкам после ключевого слова. Познакомимся еще с несколькими и научимся писать пользовательские функции. Пользовательские функции позволяют автоматизировать повторяющиеся действия и делают код легко читаемым.

Вот наш вектор

```{r}
NAs_NANs
```

Длину вектора можно вычислить при помощи функции `length()`

```{r}
length(NAs_NANs)
```

Сумму элементов вектора при помощи функции `sum()`

```{r}
sum(NAs_NANs)
```

Упс! Почему-то получилось NA

Чтобы узнать, почему и как это исправить - посмотрите в help("sum"). 
Выяснится, что у функции sum() есть аргумент na.rm, который по умолчанию принимает значение FALSE, то есть NA не учитываются при подсчете суммы.

Если мы передадим функции sum аргумент na.rm = TRUE, то получится правильная сумма

```{r}
sum(NAs_NANs, na.rm = TRUE)
```

Теперь давайте попробуем вручную посчитать среднее значение элементов в векторе NAs_NANs и положить его в переменную

Осторожно! В знаменателе должна быть не просто длина вектора, а число элементов, которые не равны NA

```{r}
a <- sum(NAs_NANs, na.rm = TRUE) / (length(NAs_NANs) - 1)
a
```

Проверяем при помощи встроенной функции mean()

```{r}
mean(NAs_NANs)
```

Она тоже не работает, если в векторе есть NA, но у нее тоже есть аргумент na.rm

```{r}
mean(NAs_NANs, na.rm = TRUE)
```

Попробуем написать пользовательскую функцию mmean(), которая будет по умолчанию считать среднее значение элементов в векторе с учетом пропущенных значений (NA)

```{r}
mmean <- function(x){
  mean(x, na.rm = TRUE)
  }
```

В этом коде:
- mmean - переменная, название функции. В эту переменную мы складываем функцию, которую создает функция function()
- function() - функция, которая делает функции. В скобках перечисляются аргументы (названия переменных, которые мы передаем в функцию, чтобы она что-то сделала с ними)
- { } - в фигурных скобках тело функции - последовательность действий, которую нужно сделать с аргументами

У больших функций бывает еще инструкция return(), которая сообщает, что именно должна возвращать наша функция. Вот как выглядела бы наша функция с этой инструкцией

```{r}
mmean <- function(x){
  res <- mean(x, na.rm = TRUE)
  return(res)
}
```

Проверим нашу функцию при помощи встроенной функции

```{r}
mean(vect_num, na.rm = TRUE)
mmean(vect_num)
```

Работает
